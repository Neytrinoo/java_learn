package com.company;

public class Main {

    public static void main(String[] args) {
        int num;
        num = 100;
        System.out.println("Это переменная num: " + num);
        num *= 2;
        System.out.print("Значение переменной num * 2 равно ");
        System.out.println(num);
        int x, y;
        x = 10;
        y = 20;
        if (x < y) System.out.println("x lost than y");
        x *= 2;
        if (x == y) System.out.println("But now x equal y");
        x *= 2;
        if (x > y) System.out.println("Not now now x more than y");
        if (x == y) System.out.println("You won't see it");

        /*
            Продемонстрировать применение цикла for.
            Присвоить исходному файлу имя "Forтest.java"
        */
        for (x = 0; x < 10; x++) System.out.println("Значение x: " + x);

        for (x = 0; x < 1; x++) {
            System.out.println("Значение x: " + x);
        }
        for (int k = 0; k < 4; k++) System.out.println("Значение какашки: " + k); // k - локальная переменная, недоступная вне цикла
        double pi, r, s;
        r = 10.8;
        pi = 3.1416;
        s = pi * r * r;
        // радиус окружности
        // приблизительное значение числа пи
        // вычислить площадь круга
        System.out.println("Плoщaдь круга равна " + s);

        char ch1, ch2;
        ch1 = 88;
        ch2 = 'Y'; // char'ы указываются в одинарных кавычках
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
        //Символьные переменные ведут себя как целочисленные значения
        System.out.println("ch1 содержит " + ch1);
        ch1++;
        System.out.println("ch1 теперь содержит " + ch1);

        boolean b;
        b = false;
        System.out.println("b equal " + b);
        b = true;
        System.out.println("b equal " + b);
        //значения типа boolean может управляться оператором if
        if (b) System.out.println("This code are doing");
        b = false;
        if (b) System.out.println("This code aren't doing");
        // результат сравнения - значение типа boolean
        System.out.println("10 > 9 равно " + (10 > 9));

        x = 123_456_789; // при компиляции знаки подчеркивания игнорируются
        double num2 = 9_423_497.1_0_9;
        System.out.println(x + " " + num2);

        double a1 = 3.0, b1 = 4.0; // a1 and b1 объявляются константами
        double c1 = Math.sqrt(a1 * a1 + b1 * b1); // c1 объявляется динамически. Math - встроенный клас, у которого есть метод sqrt - вычисление квадратного корня
        System.out.println("Гипотенуза равна " + c1);

        x = 10;
        if (x == 10) { // начало новой области видимости, доступной только этому блоку кода
            int y1 = 20;
            //Обе переменные x и y1 доступны в этой области действия
            // но мы не можем инициализировать во внутреннем блоке переменную, которая была инициализированна во внешнем.
            // Т.е. мы не можем написать int x = 10;
            System.out.println("x and y: " + x + " " + y);
            x = y1 * 2;
            for (int g = 0; g < 5; g++) {
                int asd = 4; // Тут мы инициализируем новую переменную, и в каждой итерации цикла ей будет присваиваться значение 4
                // Примечание: в коде нельзя 2 раза инициализировать переменную с одинаковыми именами
                System.out.println(asd);
                asd = 3;
                System.out.println(asd);
            }
        }
        //Здесь y1 уже не доступна
        System.out.println("x равно " + x);

        byte b2;
        int i = 257;
        double d = 323.742;
        System.out.println("\nПреобразование типа int в тип byte.");
        b2 = (byte) i; // В этом случае у нас в b2 записывается остаток от деления i на макс. значение byte, т.е. остаток от деления i на 256, т.е. 1
        System.out.println("i and b2 " + i + " " + b2);
        System.out.println("Преобразование типа double в тип int.");
        i = (int) d;
        System.out.println("d and i " + d + " " + i);
        System.out.println("Преобразование типа double в тип byte.");
        b2 = (byte) d;
        System.out.println("d and b2 " + d + " " + b2);

        b2 = 50;
        b2 = (byte) (b2 * 2); // Тут, несмотря на то, что 50*2=100, и это не превышает допустимые значения byte, нужно явно указывать, что мы преобразуем в тип byte.
        //Это нужно потому, что Java автоматически при вычислениях с byte, char and short приводит их к типу int, дабы избежать переполнения

        char c2 = 'b';
        short s2 = 1024;
        float f = 5.67f;

        /*В языке Java определен ряд правил продвижения типов, применяемых к выражениям. Сначала все значения типа byte, short и char продвигаются к типу int,
        как пояснялось выше. Затем тип всего выражения продвигается к типу long, если
        один из его операндов относится к типу long. Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float. А если
        любой из операндов относится к типу douЫe, то и результат вычисления всего
        выражения относится к типу douЫe. */
        double result = (f * b2) + (i / c2) - (d * s2);
        /*В первом промежуточном выражении f * Ь тип переменной Ь продвигается
        к типу float, а результат вычисления этого выражения также относится к типу
        float. В следующем промежуточном выражении i/c тип переменной с продвигается к типу int, а результат вычисления этого выражения относится к типу int.
        Затем в промежуточном выражении d * s тип переменной s продвигается к типу
        douЬle, а результат его вычисления относится к типу douЫe. И наконец, выполняются операции с этими тремя промежуточными результирующими значениями типа float, int и douЫe. Результат сложения значений типа float и int
        относится к типу float. Затем тип разности суммарного значения типа float
        и последнего значения типа douЬle продвигается к типу douЬle, который и становится окончательным типом результата вычисления выражения в целом. */


        int month_days[]; // массив целочисленных переменных
        month_days = new int[12]; // Объявляем с помощью ключевого слова new массив из 12 целочисленных переменных. Теперь month_days будет ссылаться на массив из 12 цел. значений
        month_days[1] = 12; // Присвоили второму элементу массива значение 12

        int month_days2[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // можем объявить массив и сразу же его инициализировать
        System.out.println("В апреле " + month_days2[3] + " дней.");

        String as = "dsfa";
        System.out.println(as);


        int twoD[][] = new int[4][5]; // Двумерный массивчек 4 на 5
        int i2, j, k = 0;
        for (i2 = 0; i2 < 4; i2++)
            for (j = 0; j < 5; j++) {
                twoD[i2][j] = k;
                k++;
            }

        for (i2 = 0; i2 < 4; i2++) {
            for (j = 0; j < 5; j++)
                System.out.print(twoD[i2][j] + " ");
            System.out.println();
        }

        twoD = new int[4][]; // Мы резервируем память только для первого измерения массива. Причем 4, это значит, что тут будут индексы от 0 до 3 включительно
        twoD[0] = new int[5]; // А дальше уже можем резервировать память для остальных измерений
        twoD[1] = new int[5];
        twoD[2] = new int[5];
        twoD[3] = new int[5];

        double m[][] = { // Двумерные массивы также можно инициализировать
                {0 * 0, 1 * 0, 2 * 0, 3 * 0},
                {0 * 1, 1 * 1, 2 * 1, 3 * 1},
                {0 * 2, 1 * 2, 2 * 2, 3 * 2},
                {0 * 3, 1 * 3, 2 * 3, 3 * 3}
        };

        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++)
                System.out.print(m[i][j] + " ");
            System.out.println();
        }

        int[] nums; // Можно также указывать квадратые скобки при объявлении массива около типа данных. Это объявление абсолютно равнозначно предыдущему
        int[] nums1, nums2, nums3; // оно удобно при задании сразу нескольких массивов в одной строке

    }
}
