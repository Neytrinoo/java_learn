package com.company;

import java.util.Random;

public class Main {

    public static void main(String[] args) throws java.io.IOException {
        int num;
        num = 100;
        System.out.println("Это переменная num: " + num);
        num *= 2;
        System.out.print("Значение переменной num * 2 равно ");
        System.out.println(num);
        int x, y;
        x = 10;
        y = 20;
        if (x < y) System.out.println("x lost than y");
        x *= 2;
        if (x == y) System.out.println("But now x equal y");
        x *= 2;
        if (x > y) System.out.println("Not now now x more than y");
        if (x == y) System.out.println("You won't see it");

        /*
            Продемонстрировать применение цикла for.
            Присвоить исходному файлу имя "Forтest.java"
        */
        for (x = 0; x < 10; x++) System.out.println("Значение x: " + x);

        for (x = 0; x < 1; x++) {
            System.out.println("Значение x: " + x);
        }
        for (int k = 0; k < 4; k++) System.out.println("Значение какашки: " + k); // k - локальная переменная, недоступная вне цикла
        double pi, r, s;
        r = 10.8;
        pi = 3.1416;
        s = pi * r * r;
        // радиус окружности
        // приблизительное значение числа пи
        // вычислить площадь круга
        System.out.println("Плoщaдь круга равна " + s);

        char ch1, ch2;
        ch1 = 88;
        ch2 = 'Y'; // char'ы указываются в одинарных кавычках
        System.out.print("ch1 and ch2: ");
        System.out.println(ch1 + " " + ch2);
        //Символьные переменные ведут себя как целочисленные значения
        System.out.println("ch1 содержит " + ch1);
        ch1++;
        System.out.println("ch1 теперь содержит " + ch1);

        boolean b;
        b = false;
        System.out.println("b equal " + b);
        b = true;
        System.out.println("b equal " + b);
        //значения типа boolean может управляться оператором if
        if (b) System.out.println("This code are doing");
        b = false;
        if (b) System.out.println("This code aren't doing");
        // результат сравнения - значение типа boolean
        System.out.println("10 > 9 равно " + (10 > 9));

        x = 123_456_789; // при компиляции знаки подчеркивания игнорируются
        double num2 = 9_423_497.1_0_9;
        System.out.println(x + " " + num2);

        double a1 = 3.0, b1 = 4.0; // a1 and b1 объявляются константами
        double c1 = Math.sqrt(a1 * a1 + b1 * b1); // c1 объявляется динамически. Math - встроенный клас, у которого есть метод sqrt - вычисление квадратного корня
        System.out.println("Гипотенуза равна " + c1);

        x = 10;
        if (x == 10) { // начало новой области видимости, доступной только этому блоку кода
            int y1 = 20;
            //Обе переменные x и y1 доступны в этой области действия
            // но мы не можем инициализировать во внутреннем блоке переменную, которая была инициализированна во внешнем.
            // Т.е. мы не можем написать int x = 10;
            System.out.println("x and y: " + x + " " + y);
            x = y1 * 2;
            for (int g = 0; g < 5; g++) {
                int asd = 4; // Тут мы инициализируем новую переменную, и в каждой итерации цикла ей будет присваиваться значение 4
                // Примечание: в коде нельзя 2 раза инициализировать переменную с одинаковыми именами
                System.out.println(asd);
                asd = 3;
                System.out.println(asd);
            }
        }
        //Здесь y1 уже не доступна
        System.out.println("x равно " + x);

        byte b2;
        int i = 257;
        double d = 323.742;
        System.out.println("\nПреобразование типа int в тип byte.");
        b2 = (byte) i; // В этом случае у нас в b2 записывается остаток от деления i на макс. значение byte, т.е. остаток от деления i на 256, т.е. 1
        System.out.println("i and b2 " + i + " " + b2);
        System.out.println("Преобразование типа double в тип int.");
        i = (int) d;
        System.out.println("d and i " + d + " " + i);
        System.out.println("Преобразование типа double в тип byte.");
        b2 = (byte) d;
        System.out.println("d and b2 " + d + " " + b2);

        b2 = 50;
        b2 = (byte) (b2 * 2); // Тут, несмотря на то, что 50*2=100, и это не превышает допустимые значения byte, нужно явно указывать, что мы преобразуем в тип byte.
        //Это нужно потому, что Java автоматически при вычислениях с byte, char and short приводит их к типу int, дабы избежать переполнения

        char c2 = 'b';
        short s2 = 1024;
        float f = 5.67f;

        /*В языке Java определен ряд правил продвижения типов, применяемых к выражениям. Сначала все значения типа byte, short и char продвигаются к типу int,
        как пояснялось выше. Затем тип всего выражения продвигается к типу long, если
        один из его операндов относится к типу long. Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float. А если
        любой из операндов относится к типу douЫe, то и результат вычисления всего
        выражения относится к типу douЫe. */
        double result = (f * b2) + (i / c2) - (d * s2);
        /*В первом промежуточном выражении f * Ь тип переменной Ь продвигается
        к типу float, а результат вычисления этого выражения также относится к типу
        float. В следующем промежуточном выражении i/c тип переменной с продвигается к типу int, а результат вычисления этого выражения относится к типу int.
        Затем в промежуточном выражении d * s тип переменной s продвигается к типу
        douЬle, а результат его вычисления относится к типу douЫe. И наконец, выполняются операции с этими тремя промежуточными результирующими значениями типа float, int и douЫe. Результат сложения значений типа float и int
        относится к типу float. Затем тип разности суммарного значения типа float
        и последнего значения типа douЬle продвигается к типу douЬle, который и становится окончательным типом результата вычисления выражения в целом. */


        int month_days[]; // массив целочисленных переменных
        month_days = new int[12]; // Объявляем с помощью ключевого слова new массив из 12 целочисленных переменных. Теперь month_days будет ссылаться на массив из 12 цел. значений
        month_days[1] = 12; // Присвоили второму элементу массива значение 12

        int month_days2[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // можем объявить массив и сразу же его инициализировать
        System.out.println("В апреле " + month_days2[3] + " дней.");

        String as = "dsfa";
        System.out.println(as);


        int twoD[][] = new int[4][5]; // Двумерный массивчек 4 на 5
        int i2, j, k = 0;
        for (i2 = 0; i2 < 4; i2++)
            for (j = 0; j < 5; j++) {
                twoD[i2][j] = k;
                k++;
            }

        for (i2 = 0; i2 < 4; i2++) {
            for (j = 0; j < 5; j++)
                System.out.print(twoD[i2][j] + " ");
            System.out.println();
        }

        twoD = new int[4][]; // Мы резервируем память только для первого измерения массива. Причем 4, это значит, что тут будут индексы от 0 до 3 включительно
        twoD[0] = new int[5]; // А дальше уже можем резервировать память для остальных измерений
        twoD[1] = new int[5];
        twoD[2] = new int[5];
        twoD[3] = new int[5];

        double m[][] = { // Двумерные массивы также можно инициализировать
                {0 * 0, 1 * 0, 2 * 0, 3 * 0},
                {0 * 1, 1 * 1, 2 * 1, 3 * 1},
                {0 * 2, 1 * 2, 2 * 2, 3 * 2},
                {0 * 3, 1 * 3, 2 * 3, 3 * 3}
        };

        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++)
                System.out.print(m[i][j] + " ");
            System.out.println();
        }

        int[] nums; // Можно также указывать квадратые скобки при объявлении массива около типа данных. Это объявление абсолютно равнозначно предыдущему
        int[] nums1, nums2, nums3; // оно удобно при задании сразу нескольких массивов в одной строке


        System.out.println();
        int a3 = 1 + 1;
        int b3 = a3 * 3;
        int c3 = b3 / 4; // Если мы делим целое число на целое число, то результат будет целым числом, а не дробным
        int d3 = c3 - a3;
        int e3 = -d3;
        System.out.println("a3 = " + a3);
        System.out.println("b3 = " + b3);
        System.out.println("c3 = " + c3);
        System.out.println("d3 = " + d3);
        System.out.println("e3 = " + e3);

        double da = 1 + 1;
        double db = da * 3;
        double dc = db / 4;
        double dd = dc - da;
        double de = -dd;
        System.out.println("da = " + da);
        System.out.println("db = " + db);
        System.out.println("dc = " + dc);
        System.out.println("dd = " + dd);
        System.out.println("de = " + de);


        System.out.println();
        x = 42;
        double y2 = 42.25;
        System.out.println("x mod 10 = " + x % 10); // % - остаток от деления
        System.out.println("y2 mod 10 = " + y2 % 10);


        System.out.println("Составные арифметические операции с присваиванием");
        int a4 = 1;
        int b4 = 2;
        int c4 = 3;
        a4 += 5;
        b4 *= 4;
        c4 += a4 * b4;
        c4 %= 6;
        System.out.println("a4 = " + a4);
        System.out.println("b4 = " + b4);
        System.out.println("c4 = " + c4);


        System.out.println("Операции инкремента и декремента");
        a4 = 1;
        b4 = 2;
        int d4;
        c4 = ++b4; // В c4 записывается значение b4, увеличенное на единицу, т.к. ++ записано перед переменной b4, и ее инкрементирование произошло раньше, чем присвоение c4 ее значения
        d4 = a4++; // А здесь в d4 сначала записалось значение a4, а только потом a4 увеличилась на единицу.
        c4++;
        System.out.println("a4 = " + a4);
        System.out.println("b4 = " + b4);
        System.out.println("c4 = " + c4);
        System.out.println("d4 = " + d4);



        /*Все целочисленные типы данных (за исключением char) представлены со знаком.
        Это означает, что они могут представлять как положительные, так и отрицательные
        целочисленные значения. Отрицательные числа в Java представлены в дополнительном коде путем инвертирования (изменения 1 на О, и наоборот) всех двоичных разрядов исходного значения и последующего добавления 1 к результату. Например,
        число - 4 2 получается путем инвертирования всех двоичных разрядов числа 4 2, что
        дает двоичное значение 11О1О1О1, к которому затем добавляется 1, а в итоге это
        дает двоичное значение 11О1О11 О, или -4 2 в десятичной форме. Чтобы получить
        положительное число из отрицательного, нужно сначала инвертировать все его двоичные разряды, а затем добавить 1 к результату. Например, инвертирование числа
        -42, или 11010110 в двоичной форме, дает двоичное значение 00101001, или 41
        в десятичной форме, а после добавления к нему 1 получается число 42.
        Причина, по которой в Java (и большинстве других языков программирования)
        применяется дополнительный код, становится понятной при рассмотрении процесса перехода церез нуль. Если речь идет о значении типа byte, то нуль представлен значением О О О О О О О О. Для получения его обратного кода достаточно инвертировать все его двоичные разряды и получить двоичное значение 11111111,
        которое представляет отрицательный нуль. Но дело в том, что отрицательный нуль
        недопустим в целочисленной математике. Выходом из этого затруднения служит
        дополнительный код для представления отрицательных чисел. В этом случае к обратному коду нулевого значения добавляется 1 и получается двоичное значение
        1 О О О О О О О О. Старший единичный разряд оказывается сдвинутым влево слишком
        далеко, чтобы уместиться в значении типа byte. Тем самым достигается требуемое поведение, когда значения - О и О равнозначны, а 11111111 - двоичный код
        значения -1. В данном примере использовано значение типа byte, но тот же самый принцип можно применить ко всем целочисленным типам данных в Java. */

        /*Поразрядная унарная операция НЕ
                Эта операция обозначается знаком - и называется также поразрядным отричанием, инвертируя все двоичные разряды своего операнда. Например, число 4 2,
                представленное в следующей двоичной форме:
                00101010
                преобразуется в результате выполнения поразрядной унарной операция НЕ в следующую форму:
                11010101
                Поразрядная логическая операция И
                При выполнении поразрядной логической операции И, обозначаемой знаком
                &:, в двоичном разряде результата устанавливается 1 лишь в том случае, если соответствующие двоичные разряды в операндах также равны 1. Во всех остальных
                случаях в двоичном разряде результата устанавливается О, как показано ниже.
                00101010 42
              & 00001111 15
                00001010 10
                Поразрядная логическая операция ИЛИ
                При выполнении поразрядной логической операции ИЛИ, обозначаемой знаком 1, в двоичном разряде результата устанавливается 1, если соответствующий
                двоичный разряд в любом из операндов равен 1, как показано ниже.
                00101010 42
              | 00001111 15
                00101111 47 */

        System.out.println("Поразрядные логические операции");
        String binary[] = {"0000", "0001", "0010", "0011", "0100",
                "0110", "0111", "1000", "1001", "1010",
                "1100", "1101", "1110", "1111"};
        a4 = 3; // 0 + 2 + 1, или 0011 в двоичном представлении
        b4 = 6; // 4 + 2 + 0, или 0110 в двоичном представлении
        c4 = a4 | b4; //  | - обозначает ИЛИ
        d4 = a4 & b4; // & - обозначает И
        int e4 = a4 ^ b4; // ^ - обозначает ИСКЛЮЧАЮЩЕЕ ИЛИ
        int f4 = (~a4 & b4) | (a4 & ~b4); // ~ - обозначает НЕ
        int g4 = ~a4 & 0x0f;
        System.out.println(" а = " + binary[a4]);
        System.out.println(" Ь = " + binary[b4]);
        System.out.println(" a|b " + binary[c4]);
        System.out.println(" а&b " + binary[d4]);
        System.out.println(" а ^ b " + binary[e4]);
        System.out.println(" ~a&b | a&~b = " + binary[f4]);
        System.out.println(" ~а= " + binary[g4]);

        /*Для целей вычисления тип переменной а продвигается к типу int, поэтому
    сдвиг значения 64 (01000000) влево на две позиции приводит к значению 256
    (1 0000 0000), присваиваемому переменной i. Но переменная Ь содержит нулевое значение, поскольку после сдвига в младшем двоичном разряде устанавливается О. Единственный единичный двоичный
    разряд оказывается сдвинутым за пределы допустимого диапазона значений.
    Каждый сдвиг влево на одну позицию, по существу, удваивает исходное значение, поэтому программисты нередко пользуются такой возможностью в качестве
    эффективной альтернативы умножению на 2. Но при этом следует соблюдать осторожность. Ведь при сдвиге единичного двоичного разряда на старшую (31-ю или
    63-ю) позицию значение становится отрицательным.*/
        System.out.println("Сдвиг влево");
        byte a5 = 64, b5;
        int i5;
        i5 = a5 << 2;
        b5 = (byte) (a5 << 2);
        System.out.println("первоначальное значение a5: " + a5);
        System.out.println("i5 and b5: " + i5 + " " + b5);


        System.out.println("Сдвиги вправо: ");
        a4 = 32;
        a4 = a4 >> 2; // теперь переменная a4 содержит значение 8. Т.к. сдвиг вправо фактически означает деление на 2 столько раз, на сколько позиций мы сдвигаем.

        a4 = -1;
        a4 = a4 >>> 24; // беззнаковый сдвиг вправо. Означает, что старшие разряды, которые равны единицам, т.к. -1 в двоичном представлении - это все единицы, будут заменены нулями, а не единицами.
        System.out.println(a4);

        System.out.println("Поразрядные составные операции с присваиванием");
        a4 = 10;
        a4 >>= 4; // все равно, что a4 = a4 >> 4
        a4 |= b4; // все равно, что a4 = a4 | b4


        System.out.println("Операции отношения");
        int done = 0;
        // if (!done) - такое не допустимо в Java
        // if (done) это не стиль Java
        if (done == 0) System.out.println("Вот это - Java");
        if (done != 0) System.out.println("И вот это - Java");

        boolean a6 = true;
        boolean b6 = false;
        boolean c6 = a6 | b6;
        boolean d6 = a6 & b6;
        boolean e6 = a6 ^ b6;
        boolean f6 = (!a6 & b6) | (a6 & !b6);
        boolean g6 = !a6;
        System.out.println("a6 = " + a6);
        System.out.println("b6 = " + b6);
        System.out.println(c6);
        System.out.println(d6);
        System.out.println(e6);
        System.out.println(f6);
        System.out.println(g6);
        // Укороченные операции И и ИЛИ являются аналогами and и or в Питоне. Т.е, если мы пишем укороченную операцию ИЛИ: ||, то если левая часть истина, правая уже не будет выполняться.
        // Аналогично с И && - если левая операция ложна, то правая не будет вычисляться. if (denom != 0 && num / denom > 10) - поможет избежать ошибки деления на ноль. Т.к. если бы мы написали
        // & вместо &&, то обе часть точно бы выполнились. ПРИНЯТО ИСПОЛЬЗОВАТЬ ИМЕННО УКОРОЧЕННЫЕ ОПЕРАЦИИ В ЛОГИЧЕСКИХ ВЫРАЖЕНИЯХ. ИХ ТАКЖЕ НАЗЫВАЮТ УСЛОВНЫМИ

        int x5, y5, z5;
        x5 = y5 = z5 = 100; // Можно применять цепочки присваиваний. В z5 запишется 100, потом в y5 запишется z5, т.е. 100, а потом в x5 запишется y5, т.е. 100


        System.out.println("Тернарная операция");
        int ratio, denom = 0;
        ratio = denom == 0 ? 0 : 1123 / denom; // Операция выр1 ? выр2 : выр3 выполняется так: если выр1 - истино, то берется выр2, иначе выр3. В данном случае переменной
        // ratio присваивается значение 0, т.к. denom == 0 - истина.

        // Круглые скобки повышают предшествование заключенных в них операций. Например (a >> b) + 3 сначало выполниться сдвиг вправо, а потом уже прибавиться 3. Без скобок было бы наоборот

        // 4TH CHAPTER PASSED

        // 5TH CHAPTER START
        int bytesAvailable;
        bytesAvailable = 123;
        // вот так выглядят условные операторы в Java с фигурными скобками
        if (bytesAvailable > 0) {
            System.out.println("bytesAvailable more than 0");
        } else if (bytesAvailable == 0) {
            System.out.println("bytesAvailable equal 0");
        } else {
            System.out.println("bytesAvailable less than 0");
            System.out.println("Тут есть ошибка");
        }


        System.out.println("Оператор switch(Nintendo)");
        for (i = 0; i < 6; i++) {
            switch (i) {
                case 0: // если оператор, выбранный в switch равен значению в case, в данном случае, если i == 0, выполняется тело кейса
                    System.out.println("i equal 0");
                    break;
                case 1:
                    System.out.println("i equal 1");
                    break;
                case 2:
                    System.out.println("i equal 2");
                    break;
                case 3:
                    System.out.println("i equal 3");
                    break;
                default: // Выполняется, если не один из кейсов не выполнен. Но default писать не обязательно. Его может и не быть. Тогда switch просто ничего не сделает, если нет совпадений с case
                    System.out.println("i more that 3");
            }
        }
        for (i = 0; i < 10; i++) {
            switch (i) {
                case 0: // можно опускать break. Тогда выполнение просто продолжится, и не будет выхода из switch
                case 1:
                case 2:
                case 3:
                case 4:
                    System.out.println("i меньше 5");
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    System.out.println("i меньше 10");
                default:
                    System.out.println("равно или больше 10");
            }
        }
        // Оператор switch может быть и вложенным. И важно. switch ДЕЙСТВУЕТ БЫСТРЕЕ if
        for (i = 0; i < 10; i++) {
            switch (i) {
                case 0:
                case 1:
                    System.out.println("Да");
                    switch (i) {
                        case 0:
                            System.out.println("Нет");
                    }
                default:
                    System.out.println("равно или больше 10");
            }
        }


        System.out.println("Циклы");
        int n = 10;
        while (n > 0) {
            System.out.println("такт " + n);
            n--;
        }
        int i6 = 100, j6 = 200;
        while (++i6 < --j6) ; // у этого цикла отсутствует тело
        System.out.println("Среднее значение равно " + i6);

        System.out.println("Пример цикла do-while");
        n = 10;
        do { // Тело цикла будет выполнено минимум 1 раз в любом случае. Даже если условие цикла не выполняется ни разу.
            System.out.println("такт " + n);
        } while (--n > 0); // так короче. Не нужно минусовать n в теле цикла

        char choice;
        do {
            System.out.println("Справка по оператору:");
            System.out.println(" 1. if");
            System.out.println(" 2. switch");
            System.out.println(" 3. while");
            System.out.println(" 4. do-while");
            System.out.println(" 5. for\n");
            choice = (char) System.in.read(); // Ввод данных. Для них обязательно вверху нужен throws java.io.IOException
        } while (choice < '1' || choice > '5');
        System.out.println(choice);


        System.out.println("Циклы. For");
        for (int a = 1, j2 = 4; a < j2; a++, j2--) { // Допускается использовать несколько переменных в инициализирующей части цикла
            System.out.println("a = " + a);
            System.out.println("j2 = " + j2);
        }
        i = 1;
        boolean for_bool = false;
        for (; !for_bool; ) {
            System.out.println("i = " + i);
            if (++i == 10) for_bool = true;
        }
        // могут быть также и бесконечные циклы. for( ; ; ) {}

        System.out.println("Циклы. For each");
        int[] nums4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int sum = 0;
        for (int nu : nums4) {
            sum += nu; // Здесь в переменную nu с каждой итерацией записывается следующие значение переменной nums4. Аналогично циклу for i in array: в Python
            System.out.println("Значение nu равно " + nu);
            if (nu == 5) break; // Если nu присвоилось значение 5, прерываем цикл
            nu = 40; // Это не окажет никакого воздействия на переменную в цикле. Значение переменной в цикле не изменится
        }
        System.out.println("Сумма равна " + sum);
        int nums5[][] = new int[3][5];
        for (i = 0; i < 3; i++)
            for (j = 0; j < 5; j++)
                nums5[i][j] = (i + 1) * (j + 1);
        sum = 0;
        for (int nus[] : nums5) { // Тип переменной nus должен совпадать с типом переменных в массиве nums5. А т.к. это - многомерный массив, то nus должен быть массивом.
            for (int nusx : nus) {
                System.out.println("Значение равно: " + nusx);
                sum += nusx;
            }
            System.out.println("Сумма: " + sum);
        }

        System.out.println("Оператор break с меткой");
        outer:
        for (i = 0; i < 3; i++) {
            System.out.print("Проход " + i + ": ");
            for (j = 0; j < 100; j++) {
                if (j == 10) break outer; // выход из обоих циклов, т.к. outer - это метка на внешний цикл.
                System.out.print(j + " ");
            }
            System.out.println("Эта строка не будет выводиться");
        }
        System.out.println("Циклы завершены"); // ВАЖНО! Нельзя выполнить переход к метке с помощью break, если блок с этой меткой не содержит этот break

        for (i = 0; i < 10; i++) {
            System.out.print(i + " ");
            if (i % 2 == 0) continue; // оператор continue аналогичен этому же оператору в Python
            System.out.println();
        }

        outer:
        for (i = 0; i < 10; i++) {
            for (j = 0; j < 10; j++) {
                if (j > i) {
                    System.out.println();
                    continue outer; // Оператор continue с меткой работает также, как и break. Только continue просто продолжает итерацию внешнего цикла, а не прикращает ее
                }
                System.out.print(" " + (i * j));
            }
        }
        // оператор return аналогичен этому же оператору в Python. Он служит для выполнения фвного выхода из метода
        
    }
}
